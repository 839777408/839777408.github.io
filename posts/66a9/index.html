<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>哈夫曼树以及哈夫曼编码 | Nan</title><meta name="author" content="阿楠"><meta name="copyright" content="阿楠"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="哈夫曼树基本概念在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。 树的路径长度就是从树根到每一结点的路径长度之和。 若将树中结点赋予一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。 树的带权路径长度规定为所">
<meta property="og:type" content="article">
<meta property="og:title" content="哈夫曼树以及哈夫曼编码">
<meta property="og:url" content="https://nanzx.gitee.io/posts/66a9/index.html">
<meta property="og:site_name" content="Nan">
<meta property="og:description" content="哈夫曼树基本概念在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。 树的路径长度就是从树根到每一结点的路径长度之和。 若将树中结点赋予一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。 树的带权路径长度规定为所">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://unpkg.com/nan-picture/img/wp8.jpg">
<meta property="article:published_time" content="2020-08-13T14:26:56.000Z">
<meta property="article:modified_time" content="2020-08-13T14:26:59.000Z">
<meta property="article:author" content="阿楠">
<meta property="article:tag" content="哈夫曼树">
<meta property="article:tag" content="哈夫曼编码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unpkg.com/nan-picture/img/wp8.jpg"><link rel="shortcut icon" href="https://unpkg.com/nan-picture/img/fav.jpg"><link rel="canonical" href="https://nanzx.gitee.io/posts/66a9/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '哈夫曼树以及哈夫曼编码',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-08-13 14:26:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="./css/iconfont.css"><link rel="stylesheet" href="./css/background.css"><link rel="stylesheet" href="./css/ahzoo.css"><link rel="stylesheet" href="./css/aplayer.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://unpkg.com/nan-picture/img/head.jpg" onerror="onerror=null;src='https://unpkg.com/nan-picture/img/load.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">104</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="https://nanzx.gitee.io"><i class="fa-fw fas fa-rocket"></i><span> 镜像</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Nan"><span class="site-name">Nan</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="https://nanzx.gitee.io"><i class="fa-fw fas fa-rocket"></i><span> 镜像</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">哈夫曼树以及哈夫曼编码</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-13T14:26:56.000Z" title="发表于 2020-08-13 14:26:56">2020-08-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-08-13T14:26:59.000Z" title="更新于 2020-08-13 14:26:59">2020-08-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">数据结构和算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="哈夫曼树以及哈夫曼编码"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/66a9/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><article class="post-content" id="article-container"><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为<strong>路径</strong>。通路中分支的数目称为<strong>路径长度</strong>。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。</p>
<p><strong>树的路径长度就是从树根到每一结点的路径长度之和。</strong></p>
<p>若将树中结点赋予一个有着某种含义的数值，则这个数值称为该<strong>结点的权</strong>。<strong>结点的带权路径长度</strong>为：从根结点到该结点之间的路径长度与该结点的权的乘积。</p>
<p><strong>树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。WPL最小的就是赫夫曼树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。</strong></p>
<h2 id="哈夫曼树的创建"><a href="#哈夫曼树的创建" class="headerlink" title="哈夫曼树的创建"></a>哈夫曼树的创建</h2><p><strong>思路分析：</strong></p>
<blockquote>
<ol>
<li>每个数据都是一个节点 ，从小到大进行排序,  每个节点可以看成是一颗最简单的二叉树。</li>
<li>取出节点权值最小的两颗二叉树 。组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 。</li>
<li>再将这颗新的二叉树，以根节点的权值大小再次排序， 不断重复2-3的步骤，直到数列中，所有的数据都被处理，只剩下一个节点时就得到一颗赫夫曼树。</li>
</ol>
</blockquote>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nanzx.huffmantree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] arr = &#123; <span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">29</span>, <span class="number">6</span>, <span class="number">1</span> &#125;;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> createHuffmanTree(arr);</span><br><span class="line">		preOrder(root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">			root.preOrder();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;根节点为空，不能遍历&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">		List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">			nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">			<span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">			<span class="type">Node</span> <span class="variable">righNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">			<span class="type">Node</span> <span class="variable">parentNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(leftNode.value + righNode.value);</span><br><span class="line">			parentNode.left = leftNode;</span><br><span class="line">			parentNode.right = righNode;</span><br><span class="line"></span><br><span class="line">			nodes.remove(leftNode);</span><br><span class="line">			nodes.remove(righNode);</span><br><span class="line">			nodes.add(parentNode);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前序遍历</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.left.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.right.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Node [value=&quot;</span> + value + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.value - o.value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p><strong>基本介绍：</strong></p>
<blockquote>
<ul>
<li>哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法。</li>
<li>哈夫曼编码是哈夫曼树在电讯通信中的经典的应用之一。</li>
<li>哈夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间。</li>
<li>哈夫曼编码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码。</li>
</ul>
</blockquote>
<p><strong>原理剖析：</strong>在线转码工具 (<a target="_blank" rel="noopener" href="https://www.mokuge.com/tool/asciito16/">https://www.mokuge.com/tool/asciito16/</a> )</p>
<hr>
<p>通信领域中信息的处理方式1-<strong>定长编码</strong></p>
<p>i like like like java do you like a java       &#x2F;&#x2F; 共40个字符(包括空格)  </p>
<p>105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97  &#x2F;&#x2F;对应Ascii码</p>
<p>01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001 </p>
<p>&#x2F;&#x2F;对应的二进制</p>
<p>按照二进制来传递信息，总的长度是  359   (包括空格)</p>
<hr>
<p>通信领域中信息的处理方式2-<strong>变长编码</strong></p>
<p>i like like like java do you like a java       &#x2F;&#x2F; 共40个字符(包括空格)</p>
<p>d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9  &#x2F;&#x2F; 各个字符对应的个数</p>
<p>0&#x3D;  ,  1&#x3D;a, 10&#x3D;i, 11&#x3D;e, 100&#x3D;k, 101&#x3D;l, 110&#x3D;o, 111&#x3D;v, 1000&#x3D;j, 1001&#x3D;u, 1010&#x3D;y, 1011&#x3D;d     &#x2F;&#x2F; 说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如空格出现了9 次，编码为0 ,其它依次类推</p>
<p>按照上面给各个字符规定的编码，则我们在传输  “i like like like java do you like a java” 数据时，编码就是 10010110100…  </p>
<hr>
<p>通信领域中信息的处理方式3-<strong>赫夫曼编码</strong></p>
<p>i like like like java do you like a java       &#x2F;&#x2F; 共40个字符(包括空格)</p>
<p>d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9  &#x2F;&#x2F; 各个字符对应的个数</p>
<p>按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值</p>
<p><img src= "https://unpkg.com/nan-picture/img/load.gif" data-lazy-src="https://unpkg.com/nan-picture/blog/20220706214943.png"></p>
<blockquote>
<p>&#x2F;&#x2F;根据赫夫曼树，给各个字符规定编码 ， 向左的路径为0,向右的路径为1 ， 编码如下:</p>
<p>o : 1000   u : 10010  d : 100110   y : 100111   i : 101<br>a : 110      k : 1110    e : 1111        j : 0000       v : 0001<br>l : 001         : 01</p>
<p>按照上面的赫夫曼编码，我们的”i like like like java do you like a java”   字符串对应的编码为 (注意这里我们使用的无损压缩)</p>
<p>1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110</p>
<p>长度为 ： 133<br>说明:<br>原来长度是  359 , 压缩了  (359-133) &#x2F; 359 &#x3D; 62.9%<br>此编码满足<strong>前缀编码</strong>, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性,变长编码有多义性</p>
<p>注意, 这个赫夫曼树根据权值的排序方法不同，也可能不太一样，相同权值的字符顺序不同，这样对应的赫夫曼编码也不完全一样，但是wpl 是一样的，都是最小的。</p>
</blockquote>
<h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><h3 id="创建哈夫曼树"><a href="#创建哈夫曼树" class="headerlink" title="创建哈夫曼树"></a>创建哈夫曼树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nanzx.huffmancode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">		<span class="type">byte</span>[] contentBytes = content.getBytes();<span class="comment">//会将字符转为Ascii码存储</span></span><br><span class="line">		System.out.println(contentBytes.length);</span><br><span class="line"></span><br><span class="line">		List&lt;Node&gt; nodes = getNodes(contentBytes);</span><br><span class="line">		<span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">		preOrder(huffmanTreeRoot);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">			root.preOrder();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;根节点为空，不能遍历&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] contentBytes)</span> &#123;</span><br><span class="line">		List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">		Map&lt;Byte, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Byte, Integer&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">byte</span> b : contentBytes) &#123;</span><br><span class="line">			<span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> map.get(b);</span><br><span class="line">			<span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;</span><br><span class="line">				map.put(b, <span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				map.put(b, count + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; e : map.entrySet()) &#123;</span><br><span class="line">			nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(e.getKey(), e.getValue()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> nodes;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">			<span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">			<span class="type">Node</span> <span class="variable">righNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">			<span class="type">Node</span> <span class="variable">pareNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, leftNode.weight + righNode.weight);</span><br><span class="line">			pareNode.left = leftNode;</span><br><span class="line">			pareNode.right = righNode;</span><br><span class="line"></span><br><span class="line">			nodes.remove(leftNode);</span><br><span class="line">			nodes.remove(righNode);</span><br><span class="line">			nodes.add(pareNode);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">	Byte data;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.data = data;</span><br><span class="line">		<span class="built_in">this</span>.weight = weight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前序遍历</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.left.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.right.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Node [data=&quot;</span> + data + <span class="string">&quot;, weight=&quot;</span> + weight + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p>40<br>Node [data&#x3D;null, weight&#x3D;40]<br>Node [data&#x3D;null, weight&#x3D;17]<br>Node [data&#x3D;null, weight&#x3D;8]<br>Node [data&#x3D;108, weight&#x3D;4]<br>Node [data&#x3D;null, weight&#x3D;4]<br>Node [data&#x3D;106, weight&#x3D;2]<br>Node [data&#x3D;111, weight&#x3D;2]<br>Node [data&#x3D;32, weight&#x3D;9]<br>Node [data&#x3D;null, weight&#x3D;23]<br>Node [data&#x3D;null, weight&#x3D;10]<br>Node [data&#x3D;97, weight&#x3D;5]<br>Node [data&#x3D;105, weight&#x3D;5]<br>Node [data&#x3D;null, weight&#x3D;13]<br>Node [data&#x3D;null, weight&#x3D;5]<br>Node [data&#x3D;null, weight&#x3D;2]<br>Node [data&#x3D;100, weight&#x3D;1]<br>Node [data&#x3D;117, weight&#x3D;1]<br>Node [data&#x3D;null, weight&#x3D;3]<br>Node [data&#x3D;121, weight&#x3D;1]<br>Node [data&#x3D;118, weight&#x3D;2]<br>Node [data&#x3D;null, weight&#x3D;8]<br>Node [data&#x3D;101, weight&#x3D;4]<br>Node [data&#x3D;107, weight&#x3D;4]</p>
<h3 id="生成哈夫曼编码表"><a href="#生成哈夫曼编码表" class="headerlink" title="生成哈夫曼编码表"></a>生成哈夫曼编码表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line"><span class="comment">// 思路:</span></span><br><span class="line"><span class="comment">// 1. 将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 形式</span></span><br><span class="line"><span class="comment">// 生成的赫夫曼编码表&#123;32=01, 97=100, 100=11000, 117=11001...&#125;</span></span><br><span class="line"><span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Byte, String&gt;();</span><br><span class="line"><span class="comment">// 2. 在生成赫夫曼编码表时，需要去拼接路径, 定义一个StringBuilder存储某个叶子结点的路径</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能：将传入的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node          传入结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> code          路径： 左子结点是 0, 右子结点 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">	<span class="type">StringBuilder</span> <span class="variable">stringBuilder2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">	stringBuilder2.append(code);</span><br><span class="line">	<span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;</span><br><span class="line">		getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder2);</span><br><span class="line">		getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder2);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了调用方便，我们重载 getCodes</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		getCodes(root, <span class="string">&quot;&quot;</span>, stringBuilder);</span><br><span class="line">		<span class="keyword">return</span> huffmanCodes;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p>{32&#x3D;01, 97&#x3D;100, 100&#x3D;11000, 117&#x3D;11001, 101&#x3D;1110, 118&#x3D;11011, 105&#x3D;101, 121&#x3D;11010, 106&#x3D;0010, 107&#x3D;1111, 108&#x3D;000, 111&#x3D;0011}</p>
<h3 id="压缩成哈夫曼字节数组"><a href="#压缩成哈夫曼字节数组" class="headerlink" title="压缩成哈夫曼字节数组"></a>压缩成哈夫曼字节数组</h3><ul>
<li><p>String content &#x3D; “i like like like java do you like a java”; 原文</p>
</li>
<li><p>byte[] contentBytes &#x3D; content.getBytes();  会将原文字符转为Ascii码存储</p>
</li>
<li><p>1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100  将Ascii码用哈夫曼编码表转换</p>
<ul>
<li>byte[] huffmanCodeBytes  ，即 8位对应一个 byte放入到 huffmanCodeBytes<ul>
<li>计算机中二进制都是以补码的形式表示的。</li>
<li>huffmanCodeBytes[0] &#x3D;  10101000(补码) &#x3D;&gt; [推导  10101000&#x3D;&gt; 10101000 - 1 &#x3D;&gt; 10100111(反码)&#x3D;&gt; 11011000(原码)&#x3D; -88 ]</li>
<li>huffmanCodeBytes[0] &#x3D; -88</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.利用 huffmanCodes哈夫曼编码表 将 contentBytes 转成 赫夫曼编码对应的字符串</span></span><br><span class="line">	<span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">		stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">	&#125;</span><br><span class="line">	huffmanStr = stringBuilder;</span><br><span class="line">       </span><br><span class="line">	<span class="comment">//2.将赫夫曼编码对应的字符串每8位（补码）进行压缩（十进制数）</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">lenth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 一句话 int len = (stringBuilder.length() + 7) / 8;</span></span><br><span class="line">	<span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		lenth = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		lenth = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[lenth];</span><br><span class="line">	<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuilder.length(); i = i + <span class="number">8</span>) &#123;</span><br><span class="line">		String strByte;</span><br><span class="line">		<span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;</span><br><span class="line">			strByte = stringBuilder.substring(i);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		huffmanCodeBytes[index++] = (<span class="type">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">huffmanStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();<span class="comment">//存储赫夫曼编码对应的字符串</span></span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p>[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]</p>
<h3 id="哈夫曼数据压缩封装"><a href="#哈夫曼数据压缩封装" class="headerlink" title="哈夫曼数据压缩封装"></a>哈夫曼数据压缩封装</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个方法，将前面的方法封装起来，便于我们的调用.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是经过 赫夫曼编码处理后的字节数组(压缩后的数组)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes) &#123;</span><br><span class="line">	List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">	<span class="comment">// 根据 nodes 创建的赫夫曼树</span></span><br><span class="line">	<span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">	<span class="comment">// 对应的赫夫曼编码(根据 赫夫曼树)</span></span><br><span class="line">	Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">	<span class="comment">// 根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span></span><br><span class="line">	<span class="type">byte</span>[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span><br><span class="line">	<span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数据解压"><a href="#数据解压" class="headerlink" title="数据解压"></a>数据解压</h2><h3 id="字节转二进制字符串"><a href="#字节转二进制字符串" class="headerlink" title="字节转二进制字符串"></a>字节转二进制字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteToBitString</span><span class="params">(<span class="type">boolean</span> flag, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b; </span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;<span class="comment">//当flag为true时，补高位</span></span><br><span class="line">			temp |= <span class="number">256</span>; <span class="comment">// 按位或 256 1 0000 0000 | 0000 0001 =&gt; 1 0000 0001</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toBinaryString(temp); <span class="comment">// 返回的是temp对应的二进制的补码</span></span><br><span class="line">		<span class="keyword">if</span> (flag) &#123; </span><br><span class="line">			<span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么补高位：</strong></p>
<p>String str &#x3D; Integer.toBinaryString(56);  &#x2F;&#x2F;返回 11 1000</p>
<p>String str &#x3D; Integer.toBinaryString(56 | 256);  &#x2F;&#x2F;返回 1 0011 1000</p>
<p><strong>为什么要截取8位：</strong></p>
<p>String str &#x3D; Integer.toBinaryString(56 | 256);  &#x2F;&#x2F;返回 1 0011 1000</p>
<p>String str &#x3D; Integer.toBinaryString(-88); &#x2F;&#x2F;返回11111111111111111111111110101000</p>
<p>String str &#x3D; Integer.toBinaryString(-88 | 256); &#x2F;&#x2F;返回11111111111111111111111110101000</p>
<h3 id="哈夫曼解码"><a href="#哈夫曼解码" class="headerlink" title="哈夫曼解码"></a>哈夫曼解码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="type">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">		<span class="comment">// 1.将压缩后的字节数组转换成原先的&quot;10101000101111111...&quot;</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; huffmanBytes.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			stringBuilder.append(byteToBitString(<span class="literal">true</span>, huffmanBytes[i]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 字节数组的最后一个字节另做处理，如果是负数，flag为true；</span></span><br><span class="line">		<span class="comment">// 如果是正数，flag为false，拼接后长度与原先相等不做处理，若小于原先长度则先补0后拼接，使其与原先长度相等</span></span><br><span class="line">		<span class="keyword">if</span> (huffmanBytes[huffmanBytes.length - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			stringBuilder.append(byteToBitString(<span class="literal">true</span>, huffmanBytes[huffmanBytes.length - <span class="number">1</span>]));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> byteToBitString(<span class="literal">false</span>, huffmanBytes[huffmanBytes.length - <span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">while</span> (str.length() + stringBuilder.length() &lt; huffmanStr.length()) &#123;</span><br><span class="line">				stringBuilder.append(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			stringBuilder.append(str);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 将哈夫曼编码表转换成哈夫曼解码表</span></span><br><span class="line">		Map&lt;String, Byte&gt; huffmanDecodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Byte&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; b : huffmanCodes.entrySet()) &#123;</span><br><span class="line">			huffmanDecodes.put(b.getValue(), b.getKey());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3.把&quot;10101000101111111...&quot;按照指定的哈夫曼解码表进行解码</span></span><br><span class="line">		List&lt;Byte&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Byte&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuilder.length();) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 小的计数器</span></span><br><span class="line">			<span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="comment">// 1010100010111...</span></span><br><span class="line">				<span class="comment">// 递增的取出 key 1</span></span><br><span class="line">				<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> stringBuilder.substring(i, i + count);<span class="comment">// i 不动，让count移动，指定匹配到一个字符</span></span><br><span class="line">				b = huffmanDecodes.get(key);</span><br><span class="line">				<span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;<span class="comment">// 说明没有匹配到</span></span><br><span class="line">					count++;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 匹配到</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			list.add(b);</span><br><span class="line">			i += count;<span class="comment">// i 直接移动到 count</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">byte</span> b[] = <span class="keyword">new</span> <span class="title class_">byte</span>[list.size()];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">			b[i] = list.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：韩顺平老师的代码是最后一个字节时，flag为false，不做任何处理。</strong></p>
<p><strong>BUG:如果压缩生成的最后一个byte数为负值，会多出24位1；</strong></p>
<p>​		 <strong>如果最后一个byte为001等前面有0的正数时，还原后会少了前面的0。</strong></p>
<p><strong>所以我们另外取最后一个字节处理。</strong></p>
<h2 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">zipFile</span><span class="params">(String srcFile, String dstFile)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建输出流</span></span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="comment">// 创建文件的输入流</span></span><br><span class="line">		<span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 创建文件的输入流</span></span><br><span class="line">			is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">			<span class="comment">// 创建一个和源文件大小一样的byte[]</span></span><br><span class="line">			<span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">			<span class="comment">// 读取文件</span></span><br><span class="line">			is.read(b);</span><br><span class="line">			<span class="comment">// 直接对源文件压缩</span></span><br><span class="line">			<span class="type">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line">			<span class="comment">// 创建文件的输出流, 存放压缩文件</span></span><br><span class="line">			os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">			<span class="comment">// 创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">			oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(os);</span><br><span class="line">			<span class="comment">// 把 赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">			oos.writeObject(huffmanBytes); <span class="comment">// 我们是把</span></span><br><span class="line">			<span class="comment">// 这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用</span></span><br><span class="line">			<span class="comment">// 注意一定要把赫夫曼编码 写入压缩文件</span></span><br><span class="line">			oos.writeObject(huffmanCodes);</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				is.close();</span><br><span class="line">				oos.close();</span><br><span class="line">				os.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				System.out.println(e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="文件解压"><a href="#文件解压" class="headerlink" title="文件解压"></a>文件解压</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unZipFile</span><span class="params">(String zipFile, String dstFile)</span> &#123;</span><br><span class="line">		<span class="comment">//定义文件输入流</span></span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="comment">//定义一个对象输入流</span></span><br><span class="line">		<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="comment">//定义文件的输出流</span></span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//创建文件输入流</span></span><br><span class="line">			is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(zipFile);</span><br><span class="line">			<span class="comment">//创建一个和  is关联的对象输入流</span></span><br><span class="line">			ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(is);</span><br><span class="line">			<span class="comment">//读取byte数组  huffmanBytes</span></span><br><span class="line">			<span class="type">byte</span>[] huffmanBytes = (<span class="type">byte</span>[])ois.readObject();</span><br><span class="line">			<span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">			Map&lt;Byte,String&gt; huffmanCodes = (Map&lt;Byte,String&gt;)ois.readObject();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//解码</span></span><br><span class="line">			<span class="type">byte</span>[] bytes = decode(huffmanCodes, huffmanBytes);</span><br><span class="line">			<span class="comment">//将bytes 数组写入到目标文件</span></span><br><span class="line">			os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">			<span class="comment">//写数据到 dstFile 文件</span></span><br><span class="line">			os.write(bytes);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				os.close();</span><br><span class="line">				ois.close();</span><br><span class="line">				is.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">				System.out.println(e2.getMessage());</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "https://unpkg.com/nan-picture/img/load.gif" data-lazy-src="https://unpkg.com/nan-picture/blog/20200813152002.png"></p>
<p>可以看到压缩和解压成功了，解压后的图片与原来一致，大小也完全一样。</p>
<h2 id="哈夫曼编码压缩文件注意事项"><a href="#哈夫曼编码压缩文件注意事项" class="headerlink" title="哈夫曼编码压缩文件注意事项"></a>哈夫曼编码压缩文件注意事项</h2><ol>
<li>如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件。</li>
<li>赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件)。</li>
<li>如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://nanzx.gitee.io">阿楠</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nanzx.gitee.io/posts/66a9/">https://nanzx.gitee.io/posts/66a9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nanzx.gitee.io" target="_blank">Nan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/">哈夫曼树</a><a class="post-meta__tags" href="/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/">哈夫曼编码</a></div><div class="post_share"><div class="social-share" data-image="https://unpkg.com/nan-picture/img/wp8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://unpkg.com/nan-picture/img/微信收款码.jpg" target="_blank"><img class="post-qr-code-img" src="https://unpkg.com/nan-picture/img/微信收款码.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://unpkg.com/nan-picture/img/支付宝收款码.jpg" target="_blank"><img class="post-qr-code-img" src="https://unpkg.com/nan-picture/img/支付宝收款码.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/ff14/" title="二叉排序树"><img class="cover" src="https://unpkg.com/nan-picture/img/wp9.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">二叉排序树</div></div></a></div><div class="next-post pull-right"><a href="/posts/b66a/" title="堆排序"><img class="cover" src="https://unpkg.com/nan-picture/img/wp7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">堆排序</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.</span> <span class="toc-text">哈夫曼树的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">1.3.</span> <span class="toc-text">哈夫曼编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9"><span class="toc-number">1.4.</span> <span class="toc-text">数据压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">1.4.1.</span> <span class="toc-text">创建哈夫曼树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">生成哈夫曼编码表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E6%88%90%E5%93%88%E5%A4%AB%E6%9B%BC%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.3.</span> <span class="toc-text">压缩成哈夫曼字节数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E5%B0%81%E8%A3%85"><span class="toc-number">1.4.4.</span> <span class="toc-text">哈夫曼数据压缩封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%8E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">数据解压</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.5.1.</span> <span class="toc-text">字节转二进制字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E8%A7%A3%E7%A0%81"><span class="toc-number">1.5.2.</span> <span class="toc-text">哈夫曼解码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9"><span class="toc-number">1.6.</span> <span class="toc-text">文件压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B"><span class="toc-number">1.7.</span> <span class="toc-text">文件解压</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.8.</span> <span class="toc-text">哈夫曼编码压缩文件注意事项</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 阿楠</div><div class="footer_custom_text">世间总有赏不尽的繁华，也有尝不完的辛苦，若内心旖旎，穷山恶水也会云卷云舒。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.nanzx.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.nanzx.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.nanzx.top/',
        region: '',
        pageSize: 3,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (false) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="7500003406" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="auto" data-autoplay="true" data-lrctype="0"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>